
**背景**

该项目是一个平台，会用到 rag 功能，其中的嵌入模型使用的是用户默认的模型，但是该模型是可以被动态选择的，
而目前只有一个1024维度的向量表来存储，如果用户切换了嵌入模型，则就会存储和对话报错了

**需求**

实现一个动态路由嵌入表，参考类：/Users/xhy/course/AgentX/AgentX/src/test/java/org/xhy/infrastructure/rag/DynamicVectorTableTest.java

因此在创建数据集的时候的地方就必须要选择嵌入模型


**表设计**
1.ai_rag_qa_dataset 表添加一个嵌入模型字段 ：embedding_id,用于存储嵌入模型，这个嵌入模型是由前端传入，前端通过获取服务商模块中的获取嵌入模型接口传入
2.创建一个 embedding_model_info 表，用于记录嵌入模型对应的表名以及维度

**技术实现**

规范：
1.遵循 ddd 规范，不可 app 层调用 repo 层
2.repo 层不要手写 sql，而是在 domain 层使用 mybatisplus

### 1. 数据库表详细设计

**1.1 ai_rag_qa_dataset 表修改**
```sql
ALTER TABLE ai_rag_qa_dataset 
ADD COLUMN embedding_model_id VARCHAR(36) NOT NULL COMMENT '嵌入模型ID，关联models表',
ADD COLUMN table_name VARCHAR(100) COMMENT '对应的向量表名，冗余字段提高查询效率';
```

**1.2 embedding_model_info 表创建**
```sql
CREATE TABLE embedding_model_info (
    id VARCHAR(36) PRIMARY KEY COMMENT '主键ID',
    model_id VARCHAR(36) NOT NULL COMMENT '嵌入模型ID，关联models表',
    table_name VARCHAR(100) NOT NULL COMMENT '向量表名，格式：vector_store_{dimension}',
    dimension INT NOT NULL COMMENT '嵌入向量维度',
    detection_status TINYINT(1) DEFAULT 0 COMMENT '维度检测状态：0-检测中 1-检测成功 2-检测失败',
    table_created TINYINT(1) DEFAULT 0 COMMENT '向量表是否已创建：0-未创建 1-已创建',
    status TINYINT(1) DEFAULT 1 COMMENT '记录状态：0-禁用 1-启用',
    error_message TEXT COMMENT '检测失败时的错误信息',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    UNIQUE KEY uk_model_id (model_id),
    UNIQUE KEY uk_table_name (table_name),
    INDEX idx_dimension (dimension)
) COMMENT='嵌入模型信息表，记录模型维度和对应的向量表信息';
```

### 2. 核心领域模型设计

**2.1 EmbeddingModelInfoEntity**
```java
@TableName("embedding_model_info")
public class EmbeddingModelInfoEntity extends BaseEntity {
    private String id;
    private String modelId;
    private String tableName;
    private Integer dimension;
    private Integer detectionStatus;  // 0-检测中 1-检测成功 2-检测失败
    private Boolean tableCreated;
    private Boolean status;
    private String errorMessage;
    // getters and setters
}
```

**2.2 动态向量存储管理器（基于langchain4j框架）**
```java
@Component
public class DynamicVectorStoreManager {
    private final Map<String, EmbeddingStore<TextSegment>> storeCache = new ConcurrentHashMap<>();
    private final EmbeddingModelInfoRepository embeddingModelInfoRepository;
    
    // 注入数据库配置
    @Value("${spring.datasource.host:localhost}")
    private String dbHost;
    
    @Value("${spring.datasource.port:5432}")  
    private int dbPort;
    
    @Value("${spring.datasource.database}")
    private String dbName;
    
    @Value("${spring.datasource.username}")
    private String dbUser;
    
    @Value("${spring.datasource.password}")
    private String dbPassword;
    
    /**
     * 获取或创建向量存储实例
     * 表命名规则：vector_store_{dimension}
     */
    public EmbeddingStore<TextSegment> getOrCreateEmbeddingStore(String modelId) {
        EmbeddingModelInfoEntity modelInfo = embeddingModelInfoRepository.getByModelId(modelId);
        if (modelInfo == null || !modelInfo.getTableCreated()) {
            throw new BusinessException("嵌入模型对应的向量表未初始化");
        }
        
        String cacheKey = modelInfo.getTableName() + "_" + modelInfo.getDimension();
        return storeCache.computeIfAbsent(cacheKey, key -> createPgVectorStore(modelInfo));
    }
    
    /**
     * 使用langchain4j创建PgVectorEmbeddingStore实例
     */
    private EmbeddingStore<TextSegment> createPgVectorStore(EmbeddingModelInfoEntity modelInfo) {
        try {
            log.info("创建向量存储实例，表名: {}, 维度: {}", modelInfo.getTableName(), modelInfo.getDimension());
            
            return PgVectorEmbeddingStore.builder()
                    .table(modelInfo.getTableName())           // 动态表名，例如：vector_store_1536
                    .dimension(modelInfo.getDimension())        // 动态维度，从API检测获得
                    .host(dbHost)                               // 从Spring配置获取
                    .port(dbPort)
                    .user(dbUser)  
                    .password(dbPassword)
                    .database(dbName)
                    .createTable(true)                          // 自动创建表
                    .dropTableFirst(false)                      // 不删除现有表，保留数据
                    .build();
                    
        } catch (Exception e) {
            log.error("创建向量存储实例失败，modelId: {}", modelInfo.getModelId(), e);
            throw new BusinessException("向量存储实例创建失败: " + e.getMessage());
        }
    }
    
    /**
     * 清理缓存
     */
    public void evictCache(String tableName) {
        storeCache.entrySet().removeIf(entry -> entry.getKey().startsWith(tableName + "_"));
        log.info("清理向量存储缓存，表名: {}", tableName);
    }
    
    /**
     * 获取缓存统计信息
     */
    public Map<String, Object> getCacheStats() {
        Map<String, Object> stats = new HashMap<>();
        stats.put("cacheSize", storeCache.size());
        stats.put("cachedTables", storeCache.keySet());
        return stats;
    }
}
```

### 3. 事件驱动架构实现

**3.1 嵌入模型创建事件监听器（完整实现）**
```java
@Component
@EventListener
public class EmbeddingModelCreatedEventListener {
    
    private final EmbeddingModelInfoRepository embeddingModelInfoRepository;
    private final EmbeddingDimensionDetectionService embeddingDimensionDetectionService;
    private final DynamicVectorStoreManager dynamicVectorStoreManager;
    
    @Async
    @EventListener
    public void handleModelCreatedEvent(ModelCreatedEvent event) {
        ModelEntity model = event.getModel();
        if (model.getType() != ModelType.EMBEDDING) {
            return;
        }
        
        log.info("处理嵌入模型创建事件，modelId: {}", model.getId());
        
        // 异步处理维度检测和向量表创建
        CompletableFuture.runAsync(() -> {
            try {
                processEmbeddingModelCreation(model);
            } catch (Exception e) {
                log.error("处理嵌入模型创建事件失败，modelId: {}", model.getId(), e);
            }
        });
    }
    
    private void processEmbeddingModelCreation(ModelEntity model) {
        // 1. 检查是否已存在记录
        EmbeddingModelInfoEntity existingInfo = embeddingModelInfoRepository.findByModelId(model.getId());
        if (existingInfo != null) {
            log.info("嵌入模型信息已存在，跳过处理，modelId: {}", model.getId());
            return;
        }
        
        // 2. 创建检测中状态的记录
        EmbeddingModelInfoEntity modelInfo = createDetectingRecord(model);
        
        // 3. 动态检测维度
        try {
            log.info("开始检测嵌入模型维度，modelId: {}", model.getId());
            int dimension = embeddingDimensionDetectionService.detectDimension(model);
            updateDetectionSuccess(modelInfo, dimension);
            
            // 4. 创建向量表（通过langchain4j自动创建）
            createVectorTable(modelInfo);
            
            log.info("嵌入模型初始化完成，modelId: {}, dimension: {}, tableName: {}", 
                model.getId(), dimension, modelInfo.getTableName());
            
        } catch (Exception e) {
            log.error("嵌入模型维度检测失败，modelId: {}", model.getId(), e);
            updateDetectionFailure(modelInfo, e.getMessage());
        }
    }
    
    /**
     * 创建检测中状态的记录
     */
    private EmbeddingModelInfoEntity createDetectingRecord(ModelEntity model) {
        EmbeddingModelInfoEntity modelInfo = new EmbeddingModelInfoEntity();
        modelInfo.setId(UUID.randomUUID().toString());
        modelInfo.setModelId(model.getId());
        modelInfo.setDetectionStatus(0); // 检测中
        modelInfo.setTableCreated(false);
        modelInfo.setStatus(true);
        
        embeddingModelInfoRepository.insert(modelInfo);
        log.info("创建嵌入模型检测记录，modelId: {}", model.getId());
        return modelInfo;
    }
    
    /**
     * 更新检测成功状态
     */
    private void updateDetectionSuccess(EmbeddingModelInfoEntity modelInfo, int dimension) {
        String tableName = "vector_store_" + dimension;
        
        modelInfo.setDimension(dimension);
        modelInfo.setTableName(tableName);
        modelInfo.setDetectionStatus(1); // 检测成功
        modelInfo.setErrorMessage(null);
        
        embeddingModelInfoRepository.updateById(modelInfo);
        log.info("更新维度检测成功状态，modelId: {}, dimension: {}", modelInfo.getModelId(), dimension);
    }
    
    /**
     * 更新检测失败状态
     */
    private void updateDetectionFailure(EmbeddingModelInfoEntity modelInfo, String errorMessage) {
        modelInfo.setDetectionStatus(2); // 检测失败
        modelInfo.setErrorMessage(errorMessage);
        
        embeddingModelInfoRepository.updateById(modelInfo);
        log.error("更新维度检测失败状态，modelId: {}, error: {}", modelInfo.getModelId(), errorMessage);
    }
    
    /**
     * 创建向量表（通过langchain4j的PgVectorEmbeddingStore自动创建）
     */
    private void createVectorTable(EmbeddingModelInfoEntity modelInfo) {
        try {
            log.info("开始创建向量表，tableName: {}, dimension: {}", 
                modelInfo.getTableName(), modelInfo.getDimension());
            
            // 通过DynamicVectorStoreManager创建EmbeddingStore实例
            // PgVectorEmbeddingStore.builder().createTable(true) 会自动创建表结构
            EmbeddingStore<TextSegment> store = dynamicVectorStoreManager
                .getOrCreateEmbeddingStore(modelInfo.getModelId());
            
            // 标记表已创建
            modelInfo.setTableCreated(true);
            embeddingModelInfoRepository.updateById(modelInfo);
            
            log.info("向量表创建成功，tableName: {}", modelInfo.getTableName());
            
        } catch (Exception e) {
            log.error("向量表创建失败，tableName: {}", modelInfo.getTableName(), e);
            updateDetectionFailure(modelInfo, "向量表创建失败: " + e.getMessage());
            throw e;
        }
    }
}
```

**3.2 维度检测服务**
```java
@Service
public class EmbeddingDimensionDetectionService {
    
    private final ProviderRepository providerRepository;
    private final EmbeddingModelFactory embeddingModelFactory;
    
    /**
     * 动态检测嵌入模型维度
     * 完全基于API调用，无静态映射
     */
    public int detectDimension(ModelEntity model) {
        try {
            // 获取服务商配置
            ProviderEntity provider = providerRepository.getById(model.getProviderId());
            if (provider == null) {
                throw new BusinessException("服务商不存在");
            }
            
            // 构建嵌入模型配置
            EmbeddingModelFactory.EmbeddingConfig config = buildEmbeddingConfig(provider, model);
            
            // 创建嵌入模型实例
            OpenAiEmbeddingModel embeddingModel = embeddingModelFactory.createEmbeddingModel(config);
            
            // 使用测试文本检测维度
            Embedding testEmbedding = embeddingModel.embed("维度检测测试文本").content();
            int dimension = testEmbedding.dimension();
            
            log.info("成功检测到嵌入模型维度，modelId: {}, dimension: {}", model.getId(), dimension);
            return dimension;
            
        } catch (Exception e) {
            log.error("嵌入模型维度检测失败，modelId: {}", model.getId(), e);
            throw new BusinessException("嵌入模型维度检测失败: " + e.getMessage());
        }
    }
    
    private EmbeddingModelFactory.EmbeddingConfig buildEmbeddingConfig(ProviderEntity provider, ModelEntity model) {
        // 从服务商配置中提取API Key和Base URL
        ProviderConfig config = provider.getConfig();
        return new EmbeddingModelFactory.EmbeddingConfig(
            config.getApiKey(),
            config.getBaseUrl(),
            model.getModelEndpoint()  // 使用模型的实际部署名称
        );
    }
}
```

### 4. RAG流程改造实现

**4.1 数据集创建流程改造**
```java
@Service
public class RagQaDatasetDomainService {
    
    /**
     * 创建数据集时必须指定嵌入模型
     */
    public RagQaDatasetEntity createDataset(CreateDatasetRequest request, String userId) {
        // 1. 验证嵌入模型是否存在且可用
        ModelEntity embeddingModel = validateEmbeddingModel(request.getEmbeddingModelId());
        
        // 2. 检查嵌入模型是否已完成初始化
        EmbeddingModelInfoEntity modelInfo = embeddingModelInfoRepository.getByModelId(request.getEmbeddingModelId());
        if (modelInfo == null || !modelInfo.getTableCreated()) {
            throw new BusinessException("选择的嵌入模型尚未完成初始化，请稍后重试");
        }
        
        // 3. 创建数据集
        RagQaDatasetEntity dataset = new RagQaDatasetEntity();
        BeanUtils.copyProperties(request, dataset);
        dataset.setEmbeddingModelId(request.getEmbeddingModelId());
        dataset.setTableName(modelInfo.getTableName());  // 冗余字段，提高查询效率
        dataset.setUserId(userId);
        
        ragQaDatasetRepository.insert(dataset);
        return dataset;
    }
}
```

**4.2 向量化流程改造（基于langchain4j的完整实现）**
```java
@Service
public class DocumentEmbeddingService {
    
    private final RagQaDatasetRepository ragQaDatasetRepository;
    private final ModelRepository modelRepository;
    private final ProviderRepository providerRepository;
    private final DynamicVectorStoreManager dynamicVectorStoreManager;
    private final EmbeddingModelFactory embeddingModelFactory;
    
    /**
     * 使用数据集指定的嵌入模型进行向量化
     * 不再使用用户默认嵌入模型，而是从数据集获取
     */
    public void processDocumentEmbedding(String datasetId, List<TextSegment> segments) {
        try {
            log.info("开始文档向量化处理，datasetId: {}, segmentCount: {}", datasetId, segments.size());
            
            // 1. 获取数据集信息
            RagQaDatasetEntity dataset = ragQaDatasetRepository.getById(datasetId);
            if (dataset == null) {
                throw new BusinessException("数据集不存在，datasetId: " + datasetId);
            }
            
            // 2. 获取数据集对应的EmbeddingStore（自动路由到正确的向量表）
            EmbeddingStore<TextSegment> embeddingStore = dynamicVectorStoreManager
                .getOrCreateEmbeddingStore(dataset.getEmbeddingModelId());
            
            // 3. 获取嵌入模型实例
            OpenAiEmbeddingModel embeddingModel = getEmbeddingModel(dataset.getEmbeddingModelId());
            
            // 4. 批量向量化并存储
            List<String> embeddingIds = new ArrayList<>();
            for (TextSegment segment : segments) {
                // 生成嵌入向量
                Embedding embedding = embeddingModel.embed(segment).content();
                
                // 添加数据集标识到元数据
                segment.metadata().put(MetadataConstant.DATA_SET_ID, datasetId);
                segment.metadata().put("embedding_model_id", dataset.getEmbeddingModelId());
                segment.metadata().put("created_at", String.valueOf(System.currentTimeMillis()));
                
                // 存储到对应维度的向量表中
                String embeddingId = embeddingStore.add(embedding, segment);
                embeddingIds.add(embeddingId);
                
                log.debug("向量存储成功，embeddingId: {}, dimension: {}", 
                    embeddingId, embedding.dimension());
            }
            
            log.info("文档向量化完成，datasetId: {}, 成功存储: {} 个向量", 
                datasetId, embeddingIds.size());
            
        } catch (Exception e) {
            log.error("文档向量化失败，datasetId: {}", datasetId, e);
            throw new BusinessException("文档向量化失败: " + e.getMessage());
        }
    }
    
    /**
     * 批量删除向量
     */
    public void deleteDocumentEmbeddings(String datasetId, List<String> embeddingIds) {
        try {
            RagQaDatasetEntity dataset = ragQaDatasetRepository.getById(datasetId);
            EmbeddingStore<TextSegment> embeddingStore = dynamicVectorStoreManager
                .getOrCreateEmbeddingStore(dataset.getEmbeddingModelId());
            
            for (String embeddingId : embeddingIds) {
                embeddingStore.remove(embeddingId);
            }
            
            log.info("批量删除向量完成，datasetId: {}, count: {}", datasetId, embeddingIds.size());
            
        } catch (Exception e) {
            log.error("批量删除向量失败，datasetId: {}", datasetId, e);
            throw new BusinessException("删除向量失败: " + e.getMessage());
        }
    }
    
    /**
     * 根据modelId获取嵌入模型实例
     */
    private OpenAiEmbeddingModel getEmbeddingModel(String modelId) {
        ModelEntity model = modelRepository.getById(modelId);
        if (model == null || model.getType() != ModelType.EMBEDDING) {
            throw new BusinessException("嵌入模型不存在或类型错误，modelId: " + modelId);
        }
        
        ProviderEntity provider = providerRepository.getById(model.getProviderId());
        if (provider == null) {
            throw new BusinessException("服务商不存在，providerId: " + model.getProviderId());
        }
        
        EmbeddingModelFactory.EmbeddingConfig config = buildEmbeddingConfig(provider, model);
        return embeddingModelFactory.createEmbeddingModel(config);
    }
    
    private EmbeddingModelFactory.EmbeddingConfig buildEmbeddingConfig(ProviderEntity provider, ModelEntity model) {
        ProviderConfig config = provider.getConfig();
        return new EmbeddingModelFactory.EmbeddingConfig(
            config.getApiKey(),
            config.getBaseUrl(),
            model.getModelEndpoint()
        );
    }
}
```

**4.3 RAG问答流程改造（完整搜索实现）**
```java
@Service
public class RagSearchService {
    
    private final RagQaDatasetRepository ragQaDatasetRepository;
    private final ModelRepository modelRepository;
    private final ProviderRepository providerRepository;
    private final DynamicVectorStoreManager dynamicVectorStoreManager;
    private final EmbeddingModelFactory embeddingModelFactory;
    
    /**
     * 根据数据集使用对应的嵌入模型进行相似度搜索
     * 自动路由到正确的向量表和嵌入模型
     */
    public List<EmbeddingMatch<TextSegment>> search(RagSearchRequest request) {
        try {
            log.info("开始RAG搜索，datasetId: {}, query: {}", request.getDatasetId(), request.getQuery());
            
            // 1. 获取数据集信息
            RagQaDatasetEntity dataset = ragQaDatasetRepository.getById(request.getDatasetId());
            if (dataset == null) {
                throw new BusinessException("数据集不存在，datasetId: " + request.getDatasetId());
            }
            
            // 2. 获取数据集对应的EmbeddingStore（自动路由到正确的向量表）
            EmbeddingStore<TextSegment> embeddingStore = dynamicVectorStoreManager
                .getOrCreateEmbeddingStore(dataset.getEmbeddingModelId());
            
            // 3. 使用数据集对应的嵌入模型生成查询向量
            OpenAiEmbeddingModel embeddingModel = getEmbeddingModel(dataset.getEmbeddingModelId());
            Embedding queryEmbedding = embeddingModel.embed(request.getQuery()).content();
            
            log.info("查询向量生成完成，dimension: {}, modelId: {}", 
                queryEmbedding.dimension(), dataset.getEmbeddingModelId());
            
            // 4. 构建搜索请求（添加数据集过滤）
            EmbeddingSearchRequest.Builder searchBuilder = EmbeddingSearchRequest.builder()
                .queryEmbedding(queryEmbedding)
                .maxResults(request.getTopK() != null ? request.getTopK() : 10)
                .minScore(request.getMinScore() != null ? request.getMinScore() : 0.0);
            
            // 添加数据集过滤，确保只搜索当前数据集的向量
            if (request.isFilterByDataset()) {
                searchBuilder.filter(metadata -> 
                    request.getDatasetId().equals(metadata.getString(MetadataConstant.DATA_SET_ID)));
            }
            
            EmbeddingSearchRequest searchRequest = searchBuilder.build();
            
            // 5. 在对应的向量表中执行搜索
            EmbeddingSearchResult<TextSegment> searchResult = embeddingStore.search(searchRequest);
            List<EmbeddingMatch<TextSegment>> matches = searchResult.matches();
            
            log.info("RAG搜索完成，找到 {} 个匹配结果", matches.size());
            
            // 6. 记录搜索结果详情
            for (int i = 0; i < matches.size(); i++) {
                EmbeddingMatch<TextSegment> match = matches.get(i);
                log.debug("搜索结果 {}: 相似度={}, 内容长度={}", 
                    i + 1, match.score(), match.embedded().text().length());
            }
            
            return matches;
            
        } catch (Exception e) {
            log.error("RAG搜索失败，datasetId: {}, query: {}", 
                request.getDatasetId(), request.getQuery(), e);
            throw new BusinessException("RAG搜索失败: " + e.getMessage());
        }
    }
    
    /**
     * 多数据集联合搜索
     * 支持在多个数据集中同时搜索（需要使用相同嵌入模型的数据集）
     */
    public List<EmbeddingMatch<TextSegment>> multiDatasetSearch(MultiDatasetSearchRequest request) {
        try {
            // 1. 验证所有数据集使用相同的嵌入模型
            String commonEmbeddingModelId = validateSameEmbeddingModel(request.getDatasetIds());
            
            // 2. 获取对应的EmbeddingStore
            EmbeddingStore<TextSegment> embeddingStore = dynamicVectorStoreManager
                .getOrCreateEmbeddingStore(commonEmbeddingModelId);
            
            // 3. 生成查询向量
            OpenAiEmbeddingModel embeddingModel = getEmbeddingModel(commonEmbeddingModelId);
            Embedding queryEmbedding = embeddingModel.embed(request.getQuery()).content();
            
            // 4. 构建多数据集过滤条件
            EmbeddingSearchRequest searchRequest = EmbeddingSearchRequest.builder()
                .queryEmbedding(queryEmbedding)
                .maxResults(request.getTopK())
                .minScore(request.getMinScore())
                .filter(metadata -> {
                    String datasetId = metadata.getString(MetadataConstant.DATA_SET_ID);
                    return request.getDatasetIds().contains(datasetId);
                })
                .build();
            
            // 5. 执行搜索
            EmbeddingSearchResult<TextSegment> searchResult = embeddingStore.search(searchRequest);
            
            log.info("多数据集搜索完成，数据集数量: {}, 结果数量: {}", 
                request.getDatasetIds().size(), searchResult.matches().size());
                
            return searchResult.matches();
            
        } catch (Exception e) {
            log.error("多数据集搜索失败", e);
            throw new BusinessException("多数据集搜索失败: " + e.getMessage());
        }
    }
    
    /**
     * 验证多个数据集使用相同的嵌入模型
     */
    private String validateSameEmbeddingModel(List<String> datasetIds) {
        Set<String> embeddingModelIds = new HashSet<>();
        
        for (String datasetId : datasetIds) {
            RagQaDatasetEntity dataset = ragQaDatasetRepository.getById(datasetId);
            if (dataset == null) {
                throw new BusinessException("数据集不存在，datasetId: " + datasetId);
            }
            embeddingModelIds.add(dataset.getEmbeddingModelId());
        }
        
        if (embeddingModelIds.size() > 1) {
            throw new BusinessException("多数据集搜索要求使用相同的嵌入模型，当前发现 " + 
                embeddingModelIds.size() + " 个不同的嵌入模型");
        }
        
        return embeddingModelIds.iterator().next();
    }
    
    /**
     * 根据modelId获取嵌入模型实例（复用向量化服务的方法）
     */
    private OpenAiEmbeddingModel getEmbeddingModel(String modelId) {
        ModelEntity model = modelRepository.getById(modelId);
        if (model == null || model.getType() != ModelType.EMBEDDING) {
            throw new BusinessException("嵌入模型不存在或类型错误，modelId: " + modelId);
        }
        
        ProviderEntity provider = providerRepository.getById(model.getProviderId());
        if (provider == null) {
            throw new BusinessException("服务商不存在，providerId: " + model.getProviderId());
        }
        
        EmbeddingModelFactory.EmbeddingConfig config = buildEmbeddingConfig(provider, model);
        return embeddingModelFactory.createEmbeddingModel(config);
    }
    
    private EmbeddingModelFactory.EmbeddingConfig buildEmbeddingConfig(ProviderEntity provider, ModelEntity model) {
        ProviderConfig config = provider.getConfig();
        return new EmbeddingModelFactory.EmbeddingConfig(
            config.getApiKey(),
            config.getBaseUrl(),
            model.getModelEndpoint()
        );
    }
}
```

**4.4 请求DTO定义**
```java
// 基础搜索请求
public class RagSearchRequest {
    @NotBlank(message = "数据集ID不能为空")
    private String datasetId;
    
    @NotBlank(message = "查询内容不能为空")
    private String query;
    
    private Integer topK = 10;           // 返回结果数量
    private Double minScore = 0.0;       // 最低相似度阈值
    private boolean filterByDataset = true;  // 是否按数据集过滤
    
    // getters and setters
}

// 多数据集搜索请求
public class MultiDatasetSearchRequest {
    @NotEmpty(message = "数据集ID列表不能为空")
    private List<String> datasetIds;
    
    @NotBlank(message = "查询内容不能为空")
    private String query;
    
    private Integer topK = 20;
    private Double minScore = 0.0;
    
    // getters and setters
}
```

### 5. 异常处理和容错机制

**5.1 维度检测失败处理**
```java
@Component
public class EmbeddingModelInitializationRetryService {
    
    /**
     * 重试维度检测
     */
    @Retryable(value = Exception.class, maxAttempts = 3, backoff = @Backoff(delay = 60000))
    public void retryDimensionDetection(String modelId) {
        ModelEntity model = modelRepository.getById(modelId);
        EmbeddingModelInfoEntity modelInfo = embeddingModelInfoRepository.getByModelId(modelId);
        
        try {
            int dimension = embeddingDimensionDetectionService.detectDimension(model);
            updateDetectionSuccess(modelInfo, dimension);
            createVectorTable(modelInfo);
        } catch (Exception e) {
            updateDetectionFailure(modelInfo, e.getMessage());
            throw e;
        }
    }
    
    /**
     * 定时任务重试失败的检测
     */
    @Scheduled(fixedDelay = 300000) // 5分钟执行一次
    public void retryFailedDetections() {
        List<EmbeddingModelInfoEntity> failedDetections = embeddingModelInfoRepository
            .findByDetectionStatus(DetectionStatus.FAILED);
            
        for (EmbeddingModelInfoEntity modelInfo : failedDetections) {
            try {
                retryDimensionDetection(modelInfo.getModelId());
            } catch (Exception e) {
                log.warn("重试维度检测仍然失败，modelId: {}", modelInfo.getModelId());
            }
        }
    }
}
```

**5.2 数据一致性保证**
```java
@Service
@Transactional
public class EmbeddingModelConsistencyService {
    
    /**
     * 嵌入模型删除时的数据清理
     */
    public void handleModelDeletion(String modelId) {
        // 1. 检查是否有数据集在使用
        List<RagQaDatasetEntity> datasets = ragQaDatasetRepository.findByEmbeddingModelId(modelId);
        if (!datasets.isEmpty()) {
            throw new BusinessException("该嵌入模型正在被数据集使用，无法删除");
        }
        
        // 2. 清理嵌入模型信息记录
        EmbeddingModelInfoEntity modelInfo = embeddingModelInfoRepository.getByModelId(modelId);
        if (modelInfo != null) {
            // 清理缓存
            dynamicVectorStoreManager.evictCache(modelInfo.getTableName());
            
            // 可选：删除向量表（需谨慎考虑）
            // dropVectorTableIfEmpty(modelInfo.getTableName());
            
            embeddingModelInfoRepository.deleteById(modelInfo.getId());
        }
    }
}
```

### 6. 缓存和性能优化

**6.1 多级缓存策略**
```java
@Component
public class EmbeddingModelCacheManager {
    
    @Cacheable(value = "embeddingModelInfo", key = "#modelId")
    public EmbeddingModelInfoEntity getModelInfo(String modelId) {
        return embeddingModelInfoRepository.getByModelId(modelId);
    }
    
    @Cacheable(value = "embeddingModelConfig", key = "#modelId")
    public EmbeddingModelFactory.EmbeddingConfig getModelConfig(String modelId) {
        // 缓存模型配置，避免重复查询数据库
        return buildEmbeddingConfigFromModel(modelId);
    }
    
    @CacheEvict(value = {"embeddingModelInfo", "embeddingModelConfig"}, key = "#modelId")
    public void evictModelCache(String modelId) {
        log.info("清理嵌入模型缓存，modelId: {}", modelId);
    }
}
```

### 7. 前端集成方案

**7.1 获取嵌入模型列表接口**
```java
@RestController
@RequestMapping("/api/models")
public class ModelController {
    
    /**
     * 获取可用的嵌入模型列表
     */
    @GetMapping("/embedding")
    public Result<List<ModelDTO>> getAvailableEmbeddingModels() {
        String userId = UserContext.getCurrentUserId();
        
        // 查询用户可用的嵌入模型
        List<ModelEntity> models = modelRepository.findAvailableEmbeddingModels(userId);
        
        // 过滤出已完成初始化的模型
        List<ModelDTO> availableModels = models.stream()
            .filter(model -> isModelReady(model.getId()))
            .map(ModelAssembler::toDTO)
            .toList();
            
        return Result.success(availableModels);
    }
    
    private boolean isModelReady(String modelId) {
        EmbeddingModelInfoEntity modelInfo = embeddingModelInfoRepository.getByModelId(modelId);
        return modelInfo != null && 
               modelInfo.getDetectionStatus() == DetectionStatus.SUCCESS.getCode() &&
               modelInfo.getTableCreated();
    }
}
```

**7.2 数据集创建请求DTO修改**
```java
public class CreateDatasetRequest {
    @NotBlank(message = "数据集名称不能为空")
    private String name;
    
    private String icon;
    private String description;
    
    @NotBlank(message = "必须选择嵌入模型")
    private String embeddingModelId;  // 新增字段
    
    // getters and setters
}
```

### 8. 监控和日志

**8.1 关键指标监控**
```java
@Component
public class EmbeddingModelMetrics {
    
    private final MeterRegistry meterRegistry;
    
    /**
     * 记录维度检测耗时
     */
    public void recordDimensionDetectionTime(String modelId, long duration) {
        Timer.Sample sample = Timer.start(meterRegistry);
        sample.stop(Timer.builder("embedding.model.dimension.detection.time")
                .tag("modelId", modelId)
                .register(meterRegistry));
    }
    
    /**
     * 记录向量化操作指标
     */
    public void recordEmbeddingOperation(String modelId, int segmentCount, long duration) {
        meterRegistry.counter("embedding.operations.count", 
                "modelId", modelId,
                "segmentCount", String.valueOf(segmentCount))
                .increment();
                
        meterRegistry.timer("embedding.operations.duration", "modelId", modelId)
                .record(duration, TimeUnit.MILLISECONDS);
    }
}
```

### 9. 实施步骤

1. **数据库表创建和实体类开发**（1-2天）
2. **维度检测服务和事件监听器开发**（2-3天）
3. **动态向量存储管理器开发**（2天）
4. **RAG流程改造**（3-4天）
5. **前端接口开发**（1天）
6. **异常处理和缓存优化**（2天）
7. **测试和性能调优**（2-3天）

总计：13-17个工作日

