# 对话模块计费集成说明

## 集成完成状态

✅ **已完成**：对话模块与计费系统的完整集成

## 修改文件列表

### 1. 核心消息处理器
- **AbstractMessageHandler.java**: 添加计费服务依赖注入和计费逻辑
- **ChatMessageHandler.java**: 更新构造函数支持计费服务注入
- **AgentMessageHandler.java**: 更新构造函数支持计费服务注入  
- **PreviewMessageHandler.java**: 更新构造函数支持计费服务注入

### 2. 常量类定义
- **BillingType.java**: 计费类型枚举常量
- **UsageDataKeys.java**: 用量数据键值常量
- **PricingConfigKeys.java**: 价格配置键值常量

### 3. 异常处理
- **InsufficientBalanceException.java**: 新增余额不足异常类

### 4. 策略类更新
- **ModelTokenStrategy.java**: 更新为使用统一常量
- **PerUnitStrategy.java**: 更新为使用统一常量

### 5. 测试文件
- **ModelBillingIntegrationTest.java**: 新增模型调用计费集成测试

### 6. 数据库配置
- **V20250726001__create_billing_system_tables.sql**: 更新示例商品配置

## 功能特性

### ✅ 对话前余额预检查
- 在对话开始前检查用户余额状态
- 余额小于0时阻止对话，避免资源浪费
- 余额充足时正常进行，计费后允许变为负数

### ✅ 透明计费集成
- 在模型Token统计完成后自动执行计费
- 不影响原有对话流程和用户体验
- 支持同步和流式对话两种模式

### ✅ 完善的异常处理  
- 余额不足时发送用户友好提示消息
- 计费异常不会中断对话服务
- 完整的错误日志记录便于监控

### ✅ 幂等性保证
- 基于会话ID、用户ID和时间戳生成唯一请求ID
- 防止重复计费和并发问题

### ✅ 精确的Token计费
- 分别统计输入Token和输出Token数量
- 使用模型表主键ID作为计费商品标识
- 支持不同模型的差异化定价

## 计费流程

```
1. 用户发起对话请求
   ↓
2. 【新增】检查用户余额是否≥0
   ↓
   余额不足 → 发送余额不足消息 → 阻止对话
   ↓
   余额充足 → 继续
   ↓
3. 模型处理并返回响应
   ↓  
4. 系统统计输入输出Token数量
   ↓
5. 创建计费上下文 (BillingContext)
   - type: BillingType.MODEL_USAGE.getCode()
   - serviceId: 模型表主键ID
   - usageData: {UsageDataKeys.INPUT_TOKENS: xxx, UsageDataKeys.OUTPUT_TOKENS: xxx}
   - requestId: 唯一请求标识
   - userId: 当前用户ID
   ↓
6. 调用计费服务执行扣费（允许余额变为负数）
   ↓
7. 记录使用量和费用到数据库
   ↓
8. 更新用户账户余额
```

## 异常处理策略

### 余额不足异常
- **检测**：`InsufficientBalanceException`
- **处理**：发送余额不足提示消息给用户
- **影响**：对话继续，但用户收到充值提醒

### 计费系统异常
- **检测**：`BusinessException`或其他系统异常
- **处理**：记录详细错误日志
- **影响**：对话正常继续，不影响用户体验

## 配置要求

### 数据库配置
1. 确保运行了计费系统数据库迁移脚本
2. 在`products`表中配置对应模型的计费商品
3. `service_id`字段必须与模型表的主键ID匹配

### 示例商品配置
```sql
INSERT INTO products (id, name, type, service_id, rule_id, pricing_config, status) VALUES 
('product-model-1', 'GPT-4模型服务', 'MODEL_USAGE', '1', 'rule-model-token', 
 '{"input_cost_per_million": 5.0, "output_cost_per_million": 15.0}', 1);
```

### Spring依赖注入
- 计费服务已通过构造函数注入到所有消息处理器
- MessageHandlerFactory使用Spring ApplicationContext自动处理依赖

## 监控和日志

### 成功计费日志
```
INFO - 模型调用计费成功 - 用户: user123, 模型: 1, 输入Token: 1000, 输出Token: 500, 费用已扣除
```

### 余额不足日志
```
WARN - 用户余额不足 - 用户: user123, 模型: 1, 错误: 账户余额不足
```

### 系统异常日志
```
ERROR - 计费系统异常 - 用户: user123, 模型: 1, 错误: [详细错误信息]
```

## 测试验证

### 单元测试
- `ModelBillingIntegrationTest`: 验证计费集成逻辑
- 测试正常计费、余额不足、系统异常等场景

### 集成测试建议
1. 创建测试用户账户并充值
2. 配置测试模型商品
3. 发起对话请求验证计费执行
4. 检查数据库中的使用记录和余额变化

## 部署注意事项

### 必要步骤
1. ✅ 运行数据库迁移脚本
2. ⚠️ **重要**：更新`products`表中的`service_id`字段为实际的模型表主键ID
3. ✅ 确保所有依赖的Bean正确注册到Spring容器
4. ✅ 配置日志级别以便监控计费状态

### 可选优化
- 配置Redis缓存提升计费性能
- 设置监控告警规则
- 建立定时对账机制

## 后续扩展

### 支持其他计费场景
- Agent创建计费：在Agent创建逻辑中集成计费
- API调用计费：在网关层集成请求计费
- 存储使用计费：在文件上传逻辑中集成计费

### 高级功能
- 订阅套餐支持
- 优惠券和折扣
- 分层定价策略
- 实时余额监控

---

**集成状态**: ✅ 完成  
**测试状态**: ✅ 基础测试完成  
**部署就绪**: ⚠️ 需要配置实际模型ID  

**联系方式**: 如有问题请查看相关代码注释或测试用例