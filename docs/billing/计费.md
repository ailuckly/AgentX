# AgentX 计费系统设计文档
## 1. 系统概述
为了支持 Agent 平台多样化和可扩展的计费需求，我们设计一个高度抽象、灵活的计费系统。系统的核心目标是将"计费项（商品）"与"计费逻辑（规则）"解耦，以适应未来对不同业务（如模型调用、Agent 创建、API 调用次数等）的计费需求，同时保证计费规则的可维护性和独立性。

## 2. 核心设计思想
系统遵循**关注点分离**原则，主要由以下几个核心概念组成：

+ **商品 (Product)**：定义一个"可计费项"。它不关心如何计费，只负责声明"什么东西需要计费"，并关联其业务标识和价格信息。
+ **规则 (Rule)**：定义一种抽象的"计费算法模型"。它完全独立于业务，只负责定义计算逻辑的类型，例如"按Token计费"或"按次计费"。这是一个干净的、可复用的组件。
+ **用量记录 (Usage Record)**：记录每一次由用户产生的可计费事件。这是进行账单计算和审计的基础。
+ **账户 (Account)**：管理用户的资金余额，是执行扣费的实体。

## 3. 架构与流程
系统将采用**策略模式 (Strategy Pattern)** 实现。

### 3.1 设计逻辑闭环
```plain
商品表 (存储定价参数) → 规则表 (计算策略) → 策略类 (执行计算)
     ↓                    ↓                    ↓
pricing_config         handler_key        具体实现类
```

### 3.2 运行时工作流
1. **定义**：
    - **商品 (**`Product`**)** 表中定义具体计费项，如"GPT-4o Token 费用"。每个商品会关联一条 **规则 (**`Rule`**)**，并包含自身的价格配置信息（如：输入/输出 Token 的单价）。
    - **规则 (**`Rule`**)** 表中定义纯粹的计费模型，如"模型Token计费规则"。每条规则通过一个唯一的处理器标识 (`handler_key`) 指向代码中一个具体的计费策略类。
    - **代码**中，存在一个 `BillingStrategy` 接口和多个实现该接口的策略类（如 `ModelTokenStrategy`, `PerUnitStrategy`）。
2. **运行时工作流**：
    - **步骤 1 (触发事件)**：系统中发生一个可计费事件（例如，用户调用了一次模型）。
    - **步骤 2 (识别商品)**：服务根据业务参数（如模型名称 `gpt-4o`）在 `Products` 表中找到对应的商品。
    - **步骤 3 (匹配规则)**：从商品信息中获取其关联的 `rule_id` 和价格配置 `pricing_config`。通过 `rule_id` 在 `Rules` 表中找到对应的 `handler_key`。
    - **步骤 4 (执行计算)**：计费引擎根据 `handler_key` 实例化对应的计费策略类。
    - **步骤 5 (传入参数)**：将本次事件的 **用量数据** (如 `{input_tokens: 1000, output_tokens: 500}`) 和商品的 **价格配置** (`pricing_config`) 传递给策略类的计算方法。
    - **步骤 6 (得出结果)**：策略类根据内部逻辑计算出最终费用。
    - **步骤 7 (记账与扣费)**：将用量、费用等信息记入 **用量记录 (**`UsageRecords`**)** 表，并从用户 **账户 (**`Accounts`**)** 中扣除相应余额。

## 4. service_id 语义规范
为了保证模型表、Agent表等核心业务表的干净，计费系统通过商品表关联其他业务实体。不同业务类型下 `service_id` 的语义如下：

| 业务类型 | service_id 含义 | 示例值 |
| --- | --- | --- |
| `MODEL_USAGE` | 具体模型ID | `gpt-4o`, `claude-3-sonnet` |
| `AGENT_CREATION` | 固定业务标识 | `agent_creation` |
| `AGENT_USAGE` | 具体AgentID | `agent_123`, `agent_456` |
| `API_CALL` | API类型 | `public_api`, `admin_api` |
| `STORAGE_USAGE` | 固定业务标识 | `storage` |


## 5. 代码执行流程设计
### 5.1 通用计费服务
```java
@Service
public class BillingService {
    
    public void charge(String userId, BillingContext context) {
        // 1. 查询商品
        Product product = productRepository.findByTypeAndServiceId(
            context.getType(), context.getServiceId());
            
        if (product == null) {
            return; // 无计费规则，直接放行
        }
        
        // 2. 检查余额
        if (!checkBalance(userId, product, context.getUsageData())) {
            throw new InsufficientBalanceException("账户余额不足");
        }
        
        // 3. 执行计费逻辑
        executeCharging(userId, product, context.getUsageData());
    }
}
```

### 5.2 模型计费集成点
在 `AbstractMessageHandler.onCompleteResponse` 中集成：

```java
public void onCompleteResponse(String completeResponse, Integer inputTokens, Integer outputTokens) {
    // 原有逻辑：保存消息
    llmEntity.setContent(completeResponse);
    llmEntity.setTokenCount(outputTokens);
    userEntity.setTokenCount(inputTokens);
    
    // 新增：计费逻辑
    String modelId = chatContext.getModel().getModelId();
    BillingContext context = BillingContext.builder()
        .type("MODEL_USAGE")
        .serviceId(modelId)  // 直接用modelId
        .usageData(Map.of("input", inputTokens, "output", outputTokens))
        .build();
    
    try {
        billingService.charge(chatContext.getUserId(), context);
    } catch (InsufficientBalanceException e) {
        // 余额不足处理
        llmEntity.setContent("⚠️ 账户余额不足，请充值后继续使用");
        logger.warn("用户 {} 余额不足，无法完成计费", chatContext.getUserId());
    }
    
    // 原有逻辑继续...
}
```

### 5.3 Agent创建计费集成点
在 `AgentAppService.createAgent` 中集成：

```java
public AgentDTO createAgent(CreateAgentRequest request, String userId) {
    // 先检查是否需要计费
    BillingContext context = BillingContext.builder()
        .type("AGENT_CREATION")
        .serviceId("agent_creation")  // 固定标识
        .usageData(Map.of("quantity", 1))
        .build();
        
    billingService.charge(userId, context);
    
    // 执行创建逻辑
    return createAgentLogic(request, userId);
}
```

## 6. 数据库表结构设计
### 6.1. `products` (商品表)
负责定义可计费项、关联业务、关联计费规则，并存储其独立的价格信息。

| 字段名 | 类型 | 备注 |
| :--- | :--- | :--- |
| `id` | `BIGINT` (PK) | 商品唯一ID |
| `name` | `VARCHAR` | 商品名称 (e.g., "GPT-4o Token 费用") |
| `type` | `VARCHAR` | 商品类型 (e.g., `MODEL_USAGE`, `AGENT_CREATION`) |
| `service_id` | `VARCHAR` | 关联的业务ID (e.g., `gpt-4o`, `agent_creation`) |
| `rule_id` | `BIGINT` (FK) | **关联到 **`rules.id`**，指定计费算法模型** |
| `pricing_config` | `JSON` | **价格配置** (e.g., `{"input_cost_per_million": 5.0, "output_cost_per_million": 15.0}`) |
| `status` | `TINYINT` | 状态 (1: Active, 0: Inactive) |
| `created_at` | `DATETIME` | 创建时间 |
| `updated_at` | `DATETIME` | 更新时间 |


### 6.2. `rules` (规则表)
定义纯粹的计费规则类型，独立于任何业务。

| 字段名 | 类型 | 备注 |
| :--- | :--- | :--- |
| `id` | `BIGINT` (PK) | 规则唯一ID |
| `name` | `VARCHAR` | 规则名称 (e.g., "模型Token计费规则") |
| `handler_key` | `VARCHAR` | **规则处理器标识，映射到代码中的策略类** |
| `description` | `TEXT` | 规则描述 |
| `created_at` | `DATETIME` | 创建时间 |
| `updated_at` | `DATETIME` | 更新时间 |


### 6.3. `usage_records` (用量记录表)
记录每一次用量事件，用于审计和生成账单。

| 字段名 | 类型 | 备注 |
| :--- | :--- | :--- |
| `id` | `BIGINT` (PK) | 记录ID |
| `user_id` | `BIGINT` | 用户ID |
| `product_id` | `BIGINT` (FK) | 关联的商品ID |
| `quantity_data` | `JSON` | **用量数据** (e.g., `{"input": 1000, "output": 500}`) |
| `cost` | `DECIMAL(18, 8)` | **本次用量产生的费用** |
| `request_id` | `VARCHAR` | 原始请求ID，用于幂等性校验 |
| `billed_at` | `DATETIME` | 计费发生时间 |
| `created_at` | `DATETIME` | 创建时间 |
| `updated_at` | `DATETIME` | 更新时间 |


### 6.4. `accounts` (账户表)
存储用户的余额信息。

| 字段名 | 类型 | 备注 |
| :--- | :--- | :--- |
| `id` | `BIGINT` (PK) | 账户ID |
| `user_id` | `BIGINT` (UQ) | 用户ID |
| `balance` | `DECIMAL(18, 8)` | **账户余额** |
| `credit` | `DECIMAL(18, 8)` | **信用额度/赠送额度** |
| `total_consumed` | `DECIMAL(18, 8)` | **累计消费金额** |
| `last_transaction_at` | `DATETIME` | **最后交易时间** |
| `created_at` | `DATETIME` | 创建时间 |
| `updated_at` | `DATETIME` | 更新时间 |


## 7. 计费示例
### 7.1 模型计费示例
**商品配置**：

```sql
INSERT INTO products (name, type, service_id, rule_id, pricing_config, status) VALUES 
('GPT-4o Token费用', 'MODEL_USAGE', 'gpt-4o', 1, '{"input_cost_per_million": 5.0, "output_cost_per_million": 15.0}', 1);
```

**规则配置**：

```sql
INSERT INTO rules (name, handler_key, description) VALUES 
('模型Token计费规则', 'MODEL_TOKEN_STRATEGY', '基于输入输出Token数量进行计费');
```

**计费执行**：

1. 用户调用gpt-4o模型，消耗1000个输入token，500个输出token
2. 根据`service_id="gpt-4o"`找到商品
3. 获取`pricing_config`和`rule_id=1`
4. 根据`rule_id=1`找到`handler_key="MODEL_TOKEN_STRATEGY"`
5. 实例化`ModelTokenStrategy`类
6. 计算费用：`cost = (1000/1000000)*5.0 + (500/1000000)*15.0 = 0.0125`

### 7.2 Agent创建计费示例
**商品配置**：

```sql
INSERT INTO products (name, type, service_id, rule_id, pricing_config, status) VALUES 
('Agent创建费用', 'AGENT_CREATION', 'agent_creation', 2, '{"cost_per_unit": 10.0}', 1);
```

**规则配置**：

```sql
INSERT INTO rules (name, handler_key, description) VALUES 
('按次计费规则', 'PER_UNIT_STRATEGY', '按使用次数进行固定计费');
```

**计费执行**：

1. 用户创建一个Agent
2. 根据`type="AGENT_CREATION"`和`service_id="agent_creation"`找到商品
3. 获取`pricing_config`和`rule_id=2`
4. 根据`rule_id=2`找到`handler_key="PER_UNIT_STRATEGY"`
5. 实例化`PerUnitStrategy`类
6. 计算费用：`cost = 1 * 10.0 = 10.0`

## 8. 设计优势
1. **高度抽象**：商品->规则->策略的三层解耦设计，支持任意业务扩展
2. **逻辑闭环**：pricing_config存储参数，handler_key指向策略，完美闭环
3. **业务无侵入**：核心业务表保持干净，通过service_id关联计费
4. **灵活配置**：新增计费类型只需添加商品配置和策略实现
5. **精确计费**：使用DECIMAL类型保证金额计算精度
6. **查询简单**：一个查询确定是否需要计费，性能优良

## 9. 实施计划
### 第一阶段：基础架构
1. 创建数据库表结构
2. 实现策略模式框架
3. 实现通用计费服务

### 第二阶段：模型计费
1. 实现`ModelTokenStrategy`策略类
2. 在消息处理流程中集成计费
3. 配置官方模型商品和规则

### 第三阶段：扩展功能
1. 实现Agent创建计费
2. 添加账户管理和充值功能
3. 完善前端计费页面

### 第四阶段：高级特性
1. 支付集成
2. 订阅套餐
3. 使用统计和报表

